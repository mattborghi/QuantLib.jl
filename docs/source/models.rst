Pricing Models
==============

QuantLib.jl has various pricing models for asset pricing.

General Model Types and Methods
-------------------------------

**ConstantParameter**

.. code-block:: julia

    type ConstantParameter <: Parameter
      data::Vector{Float64}
      constraint::Constraint
    end


Calibration Helpers
~~~~~~~~~~~~~~~~~~~

**Basket Types**

.. code-block:: julia

    type NaiveBasketType <: CalibrationBasketType end
    type MaturityStrikeByDeltaGammaBasketType <: CalibrationBasketType end

** Swaption Helper**


.. code-block:: julia
    type SwaptionHelper <: CalibrationHelper
      lazyMixin::LazyMixin
      exerciseDate::Date
      endDate::Date
      maturity::Dates.Period
      swapLength::Dates.Period
      volatility::Quote
      iborIndex::IborIndex
      fixedLegTenor::TenorPeriod
      fixedLegDayCount::DayCount
      floatingLegDayCount::DayCount
      strike::Float64
      nominal::Float64
      shift::Float64
      exerciseRate::Float64
      calibCommon::CalibrationHelperCommon
      yts::YieldTermStructure
      pricingEngine::PricingEngine
      swaption::Swaption
    end

.. function:: SwaptionHelper(maturity::Dates.Period, swapLength::Dates.Period, volatility::Quote, iborIndex::IborIndex, fixedLegTenor::TenorPeriod, fixedLegDayCount::DayCount, floatingLegDayCount::DayCount, yts::YieldTermStructure, pe::PricingEngine, strike::Float64 = -1.0, nominal::Float64 = 1.0, shift::Float64 = 0.0, exerciseRate::Float64 = 0.0)
     Constructor for SwaptionHelper

.. function:: SwaptionHelper(expiryDate::Date, endDate::Date, volatility::Quote, iborIndex::IborIndex, fixedLegTenor::TenorPeriod, fixedLegDayCount::DayCount, floatingLegDayCount::DayCount, yts::YieldTermStructure, pe::PricingEngine = NullSwaptionEngine(), strike::Float64 = -1.0, nominal::Float64 = 1.0, shift::Float64 = 0.0, exerciseRate::Float64 = 0.0)

    Constructor for SwaptionHelper

.. function:: implied_volatility!(ch::CalibrationHelper, targetValue::Float64, accuracy::Float64, maxEvals::Int, minVol::Float64, maxVol::Float64)

    Calculates the black volatility implied by the model

.. function:: add_times_to!(swaptionHelper::SwaptionHelper, times::Vector{Float64})

    Add times to the calibration helper

.. function:: model_value!(sh::SwaptionHelper)

    Returns the price of the instrument according to the model

.. function:: underlying_swap!(swaptionHelper::SwaptionHelper)

    Returns the underlying swap of the swaption


Equity Models
-------------

Bates Model
~~~~~~~~~~~

Bates stochastic volatility model

.. code-block:: julia

    type BatesModel{CalibratedModelType} <: Model{CalibratedModelType}
      modT::CalibratedModelType
      hestonModel::HestonModel
      nu::ConstantParameter
      delta::ConstantParameter
      lambda::ConstantParameter
      process::BatesProcess
      common::ModelCommon
    end

.. function:: BatesModel(process::BatesProcess)

    Constructor for the Bates model, given a Bates process

Heston Model
~~~~~~~~~~~~

Heston model for the stochastic volatility of an asset

.. code-block:: julia

    type HestonModel{CalibratedModelType} <: Model{CalibratedModelType}
      modT::CalibratedModelType
      theta::ConstantParameter
      kappa::ConstantParameter
      sigma::ConstantParameter
      rho::ConstantParameter
      v0::ConstantParameter
      process::HestonProcess
      common::ModelCommon
    end

.. function:: HestonModel(process::HestonProcess)

    Constructor for a Heston model given a Heston process


Market Models
-------------

A good overview of the implementation of QuantLib.jl's market models can be seen in the `MarketModel Example <https://github.com/pazzo83/QuantLib.jl/blob/master/examples/market_model_example.jl>`_

Accounting Engines
~~~~~~~~~~~~~~~~~~

**Accounting Engine**

An engine that collects cash flows along a market-model simulation

.. code-block:: julia
    type AccountingEngine
      evolver::AbstractMarketModelEvolver
      product::MarketModelMultiProduct
      initialNumeraireValue::Float64
      numberProducts::Int
      numerairesHeld::Vector{Float64}
      numberCashFlowsThisStep::Vector{Int}
      cashFlowsGenerated::Vector{Vector{MarketModelCashFlow}}
      discounters::Vector{MarketModelDiscounter}
    end

.. function:: AccountingEngine(evolver::AbstractMarketModelEvolver, product::MarketModelMultiProduct, initialNumeraireValue::Float64)

    Constructor for the AccountingEngine, given a market model evolver, market model product, and initial numeraire value

.. function:: multiple_path_values!(ae::AccountingEngine, stats::GenericSequenceStats, numberOfPaths::Int)

    Returns the paths generated by the underlying model simulation


**Pathwise Vegas Outer Accounting Engine**

Engine collecting cash flows along a market-model simulation for doing pathwise computation of Deltas and vegas using Giles--Glasserman smoking adjoints method.
Note, only works with displaced Libor Market Model.  The method is intimately connected with log-normal Euler evolution.  We must work with discretely compounding MM account.  To compute a vega means changing the pseudo-square root at each time step So for each vega, we have a vector of matrices. So we need a vector of vectors of matrices to compute all the vegas.  We do the outermost vector by time step and inner one by which vega.  This implementation is different in that all the linear combinations by the bumps are done as late as possible, whereas PathwiseVegasAccountingEngine (not yet implemented) does them as early as possible.

.. code-block:: julia
    type PathwiseVegasOuterAccountingEngine
      evolver::LogNormalFwdRateEuler
      product::MarketModelPathwiseMultiProduct
      pseudoRootStructure::AbstractMarketModel
      vegaBumps::Vector{Vector{Matrix{Float64}}}
      numeraires::Vector{Int}
      initialNumeraireValue::Float64
      numberProducts::Int
      numberRates::Int
      numberCashFlowTimes::Int
      numberSteps::Int
      factors::Int
      numberBumps::Int
      numberElementaryVegas::Int
      jacobianComputers::Vector{RatePseudoRootJacobianAllElements}
      doDeflation::Bool
      currentForwards::Vector{Float64}
      lastForwards::Vector{Float64}
      numerairesHeld::Vector{Float64}
      numberCashFlowsThisStep::Vector{Int}
      cashFlowsGenerated::Vector{Vector{MarketModelPathWiseCashFlow}}
      discounters::Vector{MarketModelPathwiseDiscounter}
      V::Vector{Matrix{Float64}}
      LIBORRatios::Matrix{Float64}
      Discounts::Matrix{Float64}
      StepsDiscountsSquared::Matrix{Float64}
      stepsDiscounts::Vector{Float64}
      LIBORRates::Matrix{Float64}
      partials::Matrix{Float64}
      elementaryVegasThisPath::Vector{Vector{Matrix{Float64}}}
      jacobiansThisPaths::Vector{Vector{Matrix{Float64}}}
      deflatorAndDerivatives::Vector{Float64}
      fullDerivatives::Vector{Float64}
      numberCashFlowsThisIndex::Vector{Vector{Int}}
      totalCashFlowsThisIndex::Vector{Matrix{Float64}}
      cashFlowIndicesThisStep::Vector{Vector{Int}}
    end

.. function:: PathwiseVegasOuterAccountingEngine(evolver::LogNormalFwdRateEuler, product::MarketModelPathwiseMultiProduct, pseudoRootStructure::AbstractMarketModel, vegaBumps::Vector{Vector{Matrix{Float64}}}, initialNumeraireValue::Float64)

    Constructor for the PathwiseVegasOuterAccountingEngine, given a LogNormalFwdRateEuler evolver, pathwise market model product, market model, a vector of a vector of vega matrices, and an initial numeraire value.

.. function:: multiple_path_values!(pwEng::PathwiseVegasOuterAccountingEngine, means::Vector{Float64}, errors::Vector{Float64}, numberOfPaths::Int)

    Returns the path values generated by the underlying model simulation


Brownian Generators
~~~~~~~~~~~~~~~~~~~

**SobolBrownianGeneratorFactory**

Sobol Brownian generator for market model simulations.  This is an incremental brownian generator using a Sobol random sequence generator, inverse-cumulative gaussian method, and brownian bridging.
Only diagonal ordering is implemented at this time - A diagonal schema will be used to assign the variates with the best quality to the most important factors and the largest steps.

.. code-block:: julia

    type SobolDiagonalOrdering <: SobolOrdering end

    type SobolBrownianGeneratorFactory <: BrownianGeneratorFactory
      ordering::SobolOrdering
      seed::Int
    end

.. function:: create(sob::SobolBrownianGeneratorFactory, factors::Int, steps::Int)

    Spawn a Sobol Brownian generator


Evolution Description
~~~~~~~~~~~~~~~~~~~~~

Market-model evolution description

This type stores
* evolutionTimes = the times at which the rates need to be known,
* rateTimes = the times defining the rates that are to be evolved,
* relevanceRates = which rates need to be known at each time.

This type is really just a tuple of evolution and rate times
* there will be n+1 rate times expressing payment and reset times of forward rates.
* there will be any number of evolution times.
* we also store which part of the rates are relevant for pricing via relevance rates. The important part for the i-th step will then range from relevanceRates[i].first to relevanceRates[i].second. Default values for relevance rates will be 1 and n+1.

Example for n = 5
(size = 6)

+--------+--------+--------+--------+--------+--------+------------------+
|   t0   |   t1   |   t2   |   t3   |   t4   |   t5   |    rateTimes     |
+--------+--------+--------+--------+--------+--------+------------------+
|   f0   |   f1   |   f2   |   f3   |   f4   |        |   forwardRates   |
+--------+--------+--------+--------+--------+--------+------------------+
|   d0   |   d1   |   d2   |   d3   |   d4   |   d5   |   discountBonds  |
+--------+--------+--------+--------+--------+--------+------------------+
|  d0/d0 |  d1/d0 |  d2/d0 |  d3/d0 |  d4/d0 |  d5/d0 |  discountRatios  |
+--------+--------+--------+--------+--------+--------+------------------+
|  sr0   |  sr1   |  sr2   |  sr3   |  sr4   |  sr5   |  coterminalSwaps |
+--------+--------+--------+--------+--------+--------+------------------+

.. code-block:: julia

    type EvolutionDescription
      numberOfRates::Int
      rateTimes::Vector{Float64}
      evolutionTimes::Vector{Float64}
      relevanceRates::Vector{Pair{Int, Int}}
      rateTaus::Vector{Float64}
      firstAliveRate::Vector{Int}
    end

.. function:: EvolutionDescription()

    Constructor for an EvolutionDescription that generates initializes everything at 0.

.. function:: EvolutionDescription(rateTimes::Vector{Float64}, evolutionTimes::Vector{Float64}, relevanceRates::Vector{Pair{Int, Int}} = Vector{Pair{Int, Int}}())

    Constructor for an EvolutionDescription based on rate times, evolution times, and optionally relevance rates passed in.

.. function:: money_market_measure(evol::EvolutionDescription)

    Discretely compounded money market account measure: for each step the first unexpired bond is used as numeraire.


Callability
~~~~~~~~~~~

.. function:: collect_node_data!(evolver::AbstractMarketModelEvolver, product::MarketModelMultiProduct, dataProvider::MarketModelBasisSystem, rebate::MarketModelExerciseValue, control::MarketModelExerciseValue, numberOfPaths::Int, collectedData::Vector{Vector{NodeData}})

    Collects all node data generated by market model evolver

**NothingExerciseValue**

Null rebate type

.. code-block:: julia

    type NothingExerciseValue <: MarketModelExerciseValue
      numberOfExercises::Int
      rateTimes::Vector{Float64}
      isExerciseTime::BitArray{1}
      evolution::EvolutionDescription
      currentIndex::Int
      cf::MarketModelCashFlow
    end

.. function:: NothingExerciseValue(rateTimes::Vector{Float64}, isExerciseTime::BitArray{1} = BitArray{1}())

    Constructor for a NothingExerciseValue

**SwapForwardBasisSystem**

.. code-block:: julia
    type SwapForwardBasisSystem <: MarketModelBasisSystem
      rateTimes::Vector{Float64}
      exerciseTimes::Vector{Float64}
      currentIndex::Int
      rateIndex::Vector{Int}
      evolution::EvolutionDescription
    end

.. function:: SwapForwardBasisSystem(rateTimes::Vector{Float64}, exerciseTimes::Vector{Float64})

    Constructor for a SwapForwardBasisSystem, given rate times and exercise times

**LongstaffSchwartzExerciseStrategy**

.. code-block:: julia
    type LongstaffSchwartzExerciseStrategy <: ExerciseStrategy
      basisSystem::MarketModelBasisSystem
      basisCoefficients::Vector{Vector{Float64}}
      exercise::MarketModelExerciseValue
      control::MarketModelExerciseValue
      numeraires::Vector{Int}
      currentIndex::Int
      principalInNumerairePortfolio::Float64
      newPrincipal::Float64
      exerciseTimes::Vector{Float64}
      relevantTimes::Vector{Float64}
      isBasisTime::BitArray{1}
      isRebateTime::BitArray{1}
      isControlTime::BitArray{1}
      isExerciseTime::BitArray{1}
      rebateDiscounters::Vector{MarketModelDiscounter}
      controlDiscounters::Vector{MarketModelDiscounter}
      basisValues::Vector{Vector{Float64}}
      exerciseIndex::Vector{Int}
    end

.. function:: LongstaffSchwartzExerciseStrategy(basisSystem::MarketModelBasisSystem, basisCoefficients::Vector{Vector{Float64}}, evolution::EvolutionDescription, numeraires::Vector{Int}, exercise::MarketModelExerciseValue, control::MarketModelExerciseValue)

    Constructor for the LongStaff-Schwartz exercise strategy, given a MarketModelBasisSystem, basis coefficients, an EvolutionDescription, a vector of numeraires, a MarketModelExerciseValue, and a control MarketModelExerciseValue

**SwapRateTrigger**

.. code-block:: julia
    type SwapRateTrigger <: ExerciseStrategy
      rateTimes::Vector{Float64}
      swapTriggers::Vector{Float64}
      exerciseTimes::Vector{Float64}
      currentIndex::Int
      rateIndex::Vector{Int}
    end

.. function:: SwapRateTrigger(rateTimes::Vector{Float64}, swapTriggers::Vector{Float64}, exerciseTimes::Vector{Float64})

    Constructor for the SwapRateTrigger exercise strategy


Correlations
~~~~~~~~~~~~

**ExponentialForwardCorrelation**

Exponential correlation

* L = long term correlation
* beta = exponential decay of correlation between far away forward rates
* gamma = exponent for time to go
* times = vector of time dependences

.. code-block:: julia
    type ExponentialForwardCorrelation <: PiecewiseConstantCorrelation
      numberOfRates::Int
      longTermCorr::Float64
      beta::Float64
      gamma::Float64
      rateTimes::Vector{Float64}
      times::Vector{Float64}
      correlations::Vector{Matrix{Float64}}
    end

.. function:: ExponentialForwardCorrelation(rateTimes::Vector{Float64}, longTermCorr::Float64 = 0.5, beta::Float64 = 0.2, gamma::Float64 = 1.0, times::Vector{Float64} = Vector{Float64}())

    Constructor for the ExponentialForwardCorrelation type, with default values provided.


Evolvers
~~~~~~~~

Evolvers do the actual gritty work of evolving the forward rates from one time to the next

**LogNormalFwdRateEuler**

.. code-block:: julia

    type LogNormalFwdRateEuler <: AbstractMarketModelEvolver
      marketModel::AbstractMarketModel
      numeraires::Vector{Int}
      initialStep::Int
      generator::BrownianGenerator
      fixedDrifts::Vector{Vector{Float64}}
      numberOfRates::Int
      numberOfFactors::Int
      curveState::LMMCurveState
      currentStep::Int
      forwards::Vector{Float64}
      displacement::Vector{Float64}
      logForwards::Vector{Float64}
      initialLogForwards::Vector{Float64}
      drifts1::Vector{Float64}
      initialDrifts::Vector{Float64}
      brownians::Vector{Float64}
      correlatedBrownians::Vector{Float64}
      alive::Vector{Int}
      calculators::Vector{LMMDriftCalculator}
    end

.. function:: LogNormalFwdRateEuler(marketModel::AbstractMarketModel, factory::BrownianGeneratorFactory, numeraires::Vector{Int}, initialStep::Int = 1)

    Constructor for the Log-Normal Forward Rate Euler evolver, given a market model, brownian generation factory, vector of numeraires, and optionally an initial starting step.

**LogNormalFwdRatePc**

Predictor-corrector log-normal forward rate evolver

.. code-block:: julia

    type LogNormalFwdRatePc <: AbstractMarketModelEvolver
      marketModel::AbstractMarketModel
      numeraires::Vector{Int}
      initialStep::Int
      generator::BrownianGenerator
      fixedDrifts::Vector{Vector{Float64}}
      numberOfRates::Int
      numberOfFactors::Int
      curveState::LMMCurveState
      currentStep::Int
      forwards::Vector{Float64}
      displacement::Vector{Float64}
      logForwards::Vector{Float64}
      initialLogForwards::Vector{Float64}
      drifts1::Vector{Float64}
      drifts2::Vector{Float64}
      initialDrifts::Vector{Float64}
      brownians::Vector{Float64}
      correlatedBrownians::Vector{Float64}
      alive::Vector{Int}
      calculators::Vector{LMMDriftCalculator}
    end

.. function:: LogNormalFwdRatePc(marketModel::AbstractMarketModel, factory::BrownianGeneratorFactory, numeraires::Vector{Int}, initialStep::Int = 1)

    Constructor for the Log-Normal Forward Rate PC evolver, given a market model, brownian generation factory, vector of numeraires, and optionally an initial starting step.


Models
~~~~~~

**FlatVol**

Flat volatility market model

.. code-block:: julia
    type FlatVol <: AbstractMarketModel
      covariance::Vector{Matrix{Float64}}
      totalCovariance::Vector{Matrix{Float64}}
      numberOfFactors::Int
      numberOfRates::Int
      numberOfSteps::Int
      initialRates::Vector{Float64}
      displacements::Vector{Float64}
      evolution::EvolutionDescription
      pseudoRoots::Vector{Matrix{Float64}}
    end

.. function:: FlatVol(vols::Vector{Float64}, corr::PiecewiseConstantCorrelation, evolution::EvolutionDescription, numberOfFactors::Int, initialRates::Vector{Float64}, displacements::Vector{Float64})

    Constructor for the FlatVol model


Market Model Multi-Products
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Market model product types encapsulate the notion of a product: it contains the information that would be in the termsheet of the product.

It's useful to have it be able to do several products simultaneously. The products would have to have the same underlying rate times of course. The class is therefore really encapsulating the notion of a multi-product.

For each time evolved to, it generates the cash flows associated with that time for the state of the yield curve. If one was doing a callable product then this would encompass the product and its exercise strategy.

**MarketModelComposite**

Composition of two or more market-model products

.. code-block:: julia

    type MarketModelComposite <: MarketModelMultiProduct
      components::Vector{SubProduct}
      rateTimes::Vector{Float64}
      evolutionTimes::Vector{Float64}
      finalized::Bool
      currentIndex::Int
      cashFlowTimes::Vector{Float64}
      allEvolutionTimes::Vector{Vector{Float64}}
      isInSubset::Vector{BitArray{1}}
      evolution::EvolutionDescription
    end

.. function:: MarketModelComposite()

    Constructor for the MarketModelComposite

.. function:: add_product!(mm::MarketModelComposite, product::MarketModelMultiProduct, multiplier::Float64 = 1.0)

    Add a product to the composite

.. function:: finalize!(mm::MarketModelComposite)

    Finalize each of the component products


**MultiStep MarketModel Multi-Products**

Market model multi-products that can be evaluated in more than one step

**MultiStepInverseFloater**

.. code-block:: julia

    type MultiStepInverseFloater <: MultiProductMultiStep
      common::MultiProductMultiStepCommon
      fixedAccruals::Vector{Float64}
      floatingAccruals::Vector{Float64}
      fixedStrikes::Vector{Float64}
      fixedMultipliers::Vector{Float64}
      floatingSpreads::Vector{Float64}
      paymentTimes::Vector{Float64}
      payer::Bool
      multiplier::Float64
      lastIndex::Int
      currentIndex::Int
    end

.. function:: MultiStepInverseFloater(rateTimes::Vector{Float64}, fixedAccruals::Vector{Float64}, floatingAccruals::Vector{Float64}, fixedStrikes::Vector{Float64}, fixedMultipliers::Vector{Float64}, floatingSpreads::Vector{Float64}, paymentTimes::Vector{Float64}, payer::Bool = true)

    Constructor for the multi-step inverse floater multi-product

**ExerciseAdaptor**

.. code-block:: julia

    type ExerciseAdapter <: MultiProductMultiStep
      common::MultiProductMultiStepCommon
      exercise::MarketModelExerciseValue
      numberOfProducts::Int
      isExerciseTime::BitArray{1}
      currentIndex::Int
    end

.. function:: ExerciseAdapter(exercise::MarketModelExerciseValue, numberOfProducts::Int = 1)

    Constructor for an ExerciseAdaptor

**CallSpecifiedMultiProduct**

.. code-block:: julia

    type CallSpecifiedMultiProduct <: MarketModelMultiProduct
      underlying::MarketModelMultiProduct
      strategy::ExerciseStrategy
      rebate::MarketModelMultiProduct
      evolution::EvolutionDescription
      isPresent::Vector{BitArray{1}}
      cashFlowTimes::Vector{Float64}
      rebateOffset::Int
      wasCalled::Bool
      dummyCashFlowsThisStep::Vector{Int}
      dummyCashFlowsGenerated::Vector{Vector{MarketModelCashFlow}}
      currentIndex::Int
      callable::Bool
    end

.. function:: CallSpecifiedMultiProduct(underlying::MarketModelMultiProduct, strategy::ExerciseStrategy, rebate::MarketModelMultiProduct)

    Constructor for a CallSpecifiedMultiProduct


Market Model Pathwise Multi-Products
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Market model product types encapsulate the notion of a product: it contains the information that would be in the termsheet of the product.

It's useful to have it be able to do several products simultaneously. The products would have to have the same underlying rate times of course. The class is therefore really encapsulating the notion of a multi-product.

For each time evolved to, it generates the cash flows associated to that time for the state of the yield curve. If one was doing a callable product then this would encompass the product and its exercise strategy.

This class differs from market-model multi-product in that it also returns the derivative of the pay-off with respect to each forward rate


**MarketModelPathwiseInverseFloater**

Pathwise product inverse floater for doing Greeks

.. code-block:: julia

    type MarketModelPathwiseInverseFloater <: MarketModelPathwiseMultiProduct
      rateTimes::Vector{Float64}
      fixedAccruals::Vector{Float64}
      floatingAccruals::Vector{Float64}
      fixedStrikes::Vector{Float64}
      fixedMultipliers::Vector{Float64}
      floatingSpreads::Vector{Float64}
      paymentTimes::Vector{Float64}
      payer::Bool
      multiplier::Float64
      lastIndex::Int
      evolution::EvolutionDescription
      currentIndex::Int
    end

.. function:: MarketModelPathwiseInverseFloater(rateTimes::Vector{Float64}, fixedAccruals::Vector{Float64}, floatingAccruals::Vector{Float64}, fixedStrikes::Vector{Float64}, fixedMultipliers::Vector{Float64}, floatingSpreads::Vector{Float64}, paymentTimes::Vector{Float64}, payer::Bool)

    Constructor for the MarketModelPathwiseInverseFloater.

**CallSpecifiedPathwiseMultiProduct**

.. code-block:: julia

    type CallSpecifiedPathwiseMultiProduct <: MarketModelPathwiseMultiProduct
      underlying::MarketModelPathwiseMultiProduct
      strategy::ExerciseStrategy
      rebate::MarketModelPathwiseMultiProduct
      evolution::EvolutionDescription
      isPresent::Vector{BitArray{1}}
      cashFlowTimes::Vector{Float64}
      rebateOffset::Int
      wasCalled::Bool
      dummyCashFlowsThisStep::Vector{Int}
      dummyCashFlowsGenerated::Vector{Vector{MarketModelPathWiseCashFlow}}
      currentIndex::Int
      callable::Bool
    end

.. function:: CallSpecifiedPathwiseMultiProduct(underlying::MarketModelPathwiseMultiProduct, strategy::ExerciseStrategy)

    Constructor for the CallSpecifiedPathwiseMultiProduct


Pathwise Greeks
~~~~~~~~~~~~~~~

Types and methods for Greeks

**VegaBumpCollection**

There are too many pseudo-root elements to allow bumping them all independently so we cluster them together and then divide all elements into a collection of such clusters.

.. code-block:: julia

    type VegaBumpCollection
      allBumps::Vector{VegaBumpCluster}
      associatedVolStructure::AbstractMarketModel
      checked::Bool
      nonOverlapped::Bool
      isFull::Bool
    end

.. function:: VegaBumpCollection(volStructure::AbstractMarketModel, factorwiseBumping::Bool)

    Constructs the VegaBumpCollection


**VolatilityBumpInstruments**

These types are used in the Orthogonalized Bump Finder below.

.. code-block:: julia

    type VolatilityBumpInstrumentJacobianSwaption
      startIndex::Int
      endIndex::Int
    end

    type VolatilityBumpInstrumentJacobianCap
      startIndex::Int
      endIndex::Int
      strike::Float64
    end

**OrthogonalizedBumpFinder**

Pass in a market model, a list of instruments, and possible bumps.
Get out pseudo-root bumps that shift each implied vol by one percent, and leave the other instruments fixed.
If the contribution of an instrument is too correlated with other instruments used, discard it.

.. code-block:: julia

    type OrthogonalizedBumpFinder
      derivativesProducer::VolatilityBumpInstrumentJacobian
      multiplierCutoff::Float64
      tolerance::Float64
    end

.. function:: OrthogonalizedBumpFinder(bumps::VegaBumpCollection, swaptions::Vector{VolatilityBumpInstrumentJacobianSwaption}, caps::Vector{VolatilityBumpInstrumentJacobianCap}, multiplierCutoff::Float64, tolerance::Float64) = OrthogonalizedBumpFinder(VolatilityBumpInstrumentJacobian(bumps, swaptions, caps), multiplierCutoff, tolerance)

    Constructor for the OrthongalizedBumpFinder

.. function:: get_vega_bumps!(obf::OrthogonalizedBumpFinder, theBumps::Vector{Vector{Matrix{Float64}}})

    Creates the vector to pass into PathwiseVegasAccountingEngine


Short Rate Models
-----------------

General short-rate model types and methods

**PrivateConstraint**

.. code-block:: julia

    type PrivateConstraint <: Constraint
      arguments::Vector{Parameter}
    end

.. function:: test(c::PrivateConstraint, x::Vector{Float64})

    Tests if params satisfy the constraint


Short Rate Calibration Types and Methods
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Calibration Function**

Cost function for optimization methods

.. code-block:: julia

    type CalibrationFunction <: CostFunction
      model::ShortRateModel
      helpers::Vector{CalibrationHelper}
      weights::Vector{Float64}
      projection::Projection
    end

.. function:: calibrate!(model::ShortRateModel, instruments::Vector{CalibrationHelper}, method::OptimizationMethod, endCriteria::EndCriteria, constraint::Constraint = model.privateConstraint, weights::Vector{Float64} = ones(length(instruments)), fixParams::BitArray{1} = BitArray(0))

    This method calibrates the model, which generates the appropriate calibration function to be used by the passed-in optimization method.

.. function:: func_values(calibF::CalibrationFunction, params::Vector{Float64})

    Computes the cost function values in params

.. function:: value(calibF::CalibrationFunction, params::Vector{Float64})

    Computes the cost function value in params


One Factor Short Rate Models
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. function:: get_params(m::OneFactorModel)

    Returns the model parameters

**Gaussian Short Rate Model**

One-factor Gaussian short-rate model.  Formulation is in forward measure.

.. code-block:: julia

    type GSR <: Gaussian1DModel{TermStructureConsistentModelType}
      lazyMixin::LazyMixin
      modT::TermStructureConsistentModelType
      stateProcess::StochasticProcess1D
      evaluationDate::Date
      enforcesTodaysHistoricFixings::Bool
      reversion::Parameter
      sigma::Parameter
      volatilities::Vector{Quote}
      reversions::Vector{Quote}
      volstepdates::Vector{Date}
      volsteptimes::Vector{Float64}
      volsteptimesArray::Vector{Float64}
      ts::YieldTermStructure
      swapCache::Dict{CachedSwapKey, VanillaSwap}
      common::ModelCommon
    end

.. function:: GSR(ts::YieldTermStructure, volstepdates::Vector{Date}, volatilities::Vector{Float64}, reversion::Float64, T::Float64 = 60.0)

    Constructor for the Gaussian SR model

.. function:: calibrate_volatilities_iterative!(model::GSR, helpers::Vector{CalibrationHelper}, method::OptimizationMethod, endCriteria::EndCriteria, constraint::Constraint = PositiveConstraint(), weights::Vector{Float64} = Vector{Float64}())

    Iterative calibration of model.
    With fixed reversion calibrate the volatilities one by one to the given helpers. It is assumed that that volatility step dates are suitable for this, i.e. they should be identical to the fixing dates of the helpers (except for the last one where we do not need a step). Also note that the endcritera reflect only the status of the last calibration when using this method.

.. function:: get_volatilities(model::GSR)

    Returns sigma values

.. function:: get_params(model::GSR)

    Returns model params


**Hull White Model**

Single-factor Hull White model

.. code-block:: julia

    type HullWhiteFittingParameter <: Parameter
      a::Float64
      sigma::Float64
      ts::TermStructure
    end

    type HullWhite <: OneFactorModel{AffineModelType}
      modT::AffineModelType
      r0::Float64
      a::ConstantParameter
      sigma::ConstantParameter
      phi::HullWhiteFittingParameter
      ts::TermStructure
      privateConstraint::PrivateConstraint
      common::ModelCommon
    end

.. function:: HullWhite(ts::TermStructure, a::Float64 = 0.1, sigma::Float64 = 0.01)

    Constructor for the HullWhite model


**Black Karasinski Model**

Standard Black Karasinski model

.. code-block:: julia

    type BlackKarasinski <: OneFactorModel{TermStructureConsistentModelType}
      modT::TermStructureConsistentModelType
      a::ConstantParameter
      sigma::ConstantParameter
      ts::TermStructure
      privateConstraint::PrivateConstraint
      common::ModelCommon
    end

.. function:: BlackKarasinski(ts::TermStructure, a::Float64 = 0.1, sigma = 0.1)

    Constructor for the Black Karasinski model


Two Factor Short Rate Models
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**G2 Model**

Two-additive-factor gaussian model

.. code-block:: julia

    type G2FittingParameter <: Parameter
      a::Float64
      sigma::Float64
      b::Float64
      eta::Float64
      rho::Float64
      ts::TermStructure
    end

    type G2 <: TwoFactorModel{AffineModelType}
      modT::AffineModelType
      a::ConstantParameter
      sigma::ConstantParameter
      b::ConstantParameter
      eta::ConstantParameter
      rho::ConstantParameter
      phi::G2FittingParameter
      ts::TermStructure
      privateConstraint::PrivateConstraint
      common::ModelCommon
    end

.. function:: G2(ts::TermStructure, a::Float64 = 0.1, sigma::Float64 = 0.01, b::Float64 = 0.1, eta::Float64 = 0.01, rho::Float64 = -0.75)

    Constructor for the G2 model, with default values
